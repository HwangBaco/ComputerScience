# 2016101071_황제철_TASK_4

> 컴퓨터 네트워크 프로젝트 관련 정보:
> 
> 1. 팀 : 1조
> 2. 조원 : 박규현(팀장), 김민수, 김종성, 홍지승, 황제철

## 링크 계층이란?

---

링크 계층에서는 호스트/라우터 등 네트워크 장치 간 데이터를 전송하는 규칙을 바탕으로, 물리 주소를 지정하여 물리 계층을 통해 원활한 전송을 진행하고, 송수신하는 데이터의 무결성 검증을 수행합니다.  즉, 이 계층에서는 라우팅은 수행하지 않고, 데이터의 전송에 대한 부분만 다루게 됩니다. 링크 계층은 유/무선 링크를 통해 프레임 단위로 데이터를 전송합니다.

링크 계층에서 사용되는 프레임은 WLAN을 위한 IEEE 802.11 프레임 등이 있지만, 가장 일반적으로 사용되는 프레임이 이더넷 프레임이고, 이번에 분석해 볼 패킷 또한 이더넷 프레임입니다. 

![Untitled](2016101071_%E1%84%92%E1%85%AA%E1%86%BC%E1%84%8C%E1%85%A6%E1%84%8E%E1%85%A5%E1%86%AF_TASK_4%20bc1347b0e65748899e2d81939b41d523/Untitled.png)

이더넷 프레임은 네트워크 장치 간 데이터를 안전하게 전송하기 위해 사용되고, 이를 구현하기 위해 프레임 헤더에는 출발지와 목적지의 MAC 주소, 타입 필드, 페이로드, 그리고 CRC(FSC)필드로 구성됩니다. 여기서 프리엠블은 송신자와 수신자의 동기화를 위해 사용되며 7바이트 패턴으로 전달되는데, 이는 물리 계층의 헤더이기 때문에 와이어샤크에서 캡쳐되지 않는다고 합니다. 따라서 패킷 분석에서는 그 외의 부분만 분석해보도록 하겠습니다.

## 패킷 분석

---

![figure 1](2016101071_%E1%84%92%E1%85%AA%E1%86%BC%E1%84%8C%E1%85%A6%E1%84%8E%E1%85%A5%E1%86%AF_TASK_4%20bc1347b0e65748899e2d81939b41d523/Untitled%201.png)

figure 1

### Frame

![Untitled](2016101071_%E1%84%92%E1%85%AA%E1%86%BC%E1%84%8C%E1%85%A6%E1%84%8E%E1%85%A5%E1%86%AF_TASK_4%20bc1347b0e65748899e2d81939b41d523/Untitled%202.png)

`Frame 862` : 캡쳐된 프레임이 와이어샤크가 캡쳐한 862번째 프레임임을 의미합니다. 60 bytes on wire라고 하는 건 이 패킷의 전체 크기가 60바이트임을 의미합니다. 그리고 60 bytes captured인 것은 와이어샤크가 패킷을 캡쳐할 때 실제 패킷보다 일부만 캡쳐될 수 있기 때문에 나타낸 정보입니다.

`Section number 1` : wireshark가 매기는 내부적인 번호입니다. 실제 네트워크 통신에서 사용되는 프로토콜의 일부를 나타내는 정보가 아니며, 와이어샤크를 통해 패킷을 분석할 때 특정 패킷을 추적할 때 사용자의 편의를 위해 제공되는 값입니다.

`Interface id` : 패킷을 캡쳐하는 인터페이스 번호를 나타냅니다. 일반적으로 인터페이스 번호는 네트워크 장치가 여러 개의 네트워크 인터페이스를 이용할 때 사용됩니다.

![figure 2](2016101071_%E1%84%92%E1%85%AA%E1%86%BC%E1%84%8C%E1%85%A6%E1%84%8E%E1%85%A5%E1%86%AF_TASK_4%20bc1347b0e65748899e2d81939b41d523/Untitled%203.png)

figure 2

위 **figure 2**의 예시에서 라우터로 보이는 위 네트워크 장치 주변에 있는 숫자가 인터페이스 번호라고 이해하면 됩니다. 이러한 값을 통해 어느 장치에서 왔고, 어느 장치로 라우팅을 하는지에 대한 정보를 담고 있습니다. 이러한 식별자를 할당하는 것 일반적으로 라우터에서 수행되는데, 그 이유는 라우터가 라우팅 작업을 수행하기 때문입니다.그리고 라우터는 일반적으로 여러 인터페이스 아이디를 다루고 있기 때문에 포워딩 테이블을 가지고 있어서, 인터페이스에 따라 어디로 라우팅할지를 알고 있습니다.

![Untitled](2016101071_%E1%84%92%E1%85%AA%E1%86%BC%E1%84%8C%E1%85%A6%E1%84%8E%E1%85%A5%E1%86%AF_TASK_4%20bc1347b0e65748899e2d81939b41d523/Untitled%204.png)

여기서 상세 보기를 선택하면 위와 같이 나오는데, 여기서 “인터페이스 이름”이란 운영체제에서 할당한 해당 네트워크 인터페이스의 내부적인 이름을 나타냅니다.  여기서 NPF는 network packet filter를 의미하고 이는 와이어샤크가 네트워크 인터페이스를 캡처하기 위해 사용하는 드라이버입니다. \Device\NPF_까지는 식별자의 prefix라고 생각하면 쉽고, 이후 중괄호 내의 값이 해당 인터페이스의 고유값을 나타냅니다.

그리고 확인되는 것이 “인터페이스 설명”인데, 이는 해당 네트워크 인터페이스에 대한 추가 설명이 들어가며, 이 인터페이스가 wi-fi 기술을 사용하는 무선 네트워크 인터페이스임을 나타낸다고 말해주고 있습니다. 이러한 정보는 모두 사용자를 위해 와이어샤크에서 제공해주는 정보입니다.

`Encapsulation type` : 이 정보는 데이터 전송시 어떠한 프로토콜을 사용하는 데이터인지를 담아둔 정보입니다. figure 1의 정보로 미루어 보아, Ethernet 프레임으로 캡슐화 되어있다는 것을 확인할 수 있습니다.

`Arrival time` 은 패킷을 캡쳐한 시간입니다. arrival time인 이유는, 패킷이 캡쳐 장치에 도착한 시간을 나타내는 값이기 때문입니다. wireshark가 보여주는 데이터이고, 실제 패킷의 프레임에는 포함되지 않는 정보입니다.

`time shift for this packet` : 실제 패킷 전송 시간과 와이어샤크에 캡쳐된 시간이 다를 수 있으므로, 캡처된 패킷의 시간을 실제 패킷 전송 시간에 맞게 조정할 수 있게 하려고 이 값을 나타냅니다. 패킷을 우클릭하면 time shift가 있고, 이를 이용하여 조정할 수 있습니다.

![Untitled](2016101071_%E1%84%92%E1%85%AA%E1%86%BC%E1%84%8C%E1%85%A6%E1%84%8E%E1%85%A5%E1%86%AF_TASK_4%20bc1347b0e65748899e2d81939b41d523/Untitled%205.png)

근데, 제가 캡쳐한 패킷을 50개 정도 읽어봤을 때 전부 0이 나오는 걸로 봐서는 time shift가 잘 일어나진 않는 것 같습니다.

`epoch time` : 컴퓨터 시스템에서 시간을 표현하는 방식 중 하나로, UTC 기반의 기준 시각을 나타냅니다.

`time delta from previous captured time` : 직전에 캡쳐된 프레임으로부터의 간격을 ‘초’로 나타냅니다. 위 프레임 데이터에서는 0.000…초라고 나타내는 걸로 보아 직전 캡쳐 프레임과의 캡쳐 간격은 유의미한 시간 차이가 나지 않는 것으로 보입니다.

`time delta from previous displayed frame` : 직전에 표시된 프레임으로부터의 간격을 ‘초’로 나타냅니다. 위 프레임 데이터에서는 0.000…초라고 나타내는 걸로 보아 직전 캡쳐 프레임과의 표시 간격 또한 유의미한 시간 차이가 나지 않는 것으로 보입니다.

> time delta 값들의 경우 대체로 유의미한 차이가 나지 않았는데, **figure 3**를 보면 UDP 패킷의 경우는 시간 차이가 보여지는 것을 확인할 수 있었습니다.
> 
> 
> ![figure 3](2016101071_%E1%84%92%E1%85%AA%E1%86%BC%E1%84%8C%E1%85%A6%E1%84%8E%E1%85%A5%E1%86%AF_TASK_4%20bc1347b0e65748899e2d81939b41d523/Untitled%206.png)
> 
> figure 3
> 

`time since reference or first frame` : 최초 패킷 캡쳐 시점부터 현재 선택되어 있는 패킷을 캡쳐한 시점까지의 경과 시간을 ‘초’로 나타낸 값입니다. **figure 1**을 보면 862개의 패킷을 캡쳐하는 시간이 약 15초 정도 걸렸음을 알 수 있습니다.

`frame number` : 캡처된 패킷의 순번을 의미합니다. 첫번째로 캡쳐된 패킷에 1이 부여되고, 1씩 증가하는 방식으로 연속적으로 부여되므로 figure 1에서 보는 패킷은 862번째로 캡쳐된 패킷임을 알 수 있습니다.

`frame length` : 프레임의 크기를 나타냅니다. figure 1의 경우에는 ACK를 보내기 위한 패킷이었기에 그 크기가 60bytes 에 그치는 것으로 보이지만, figure 4를 참고하면 application data를 위해 859 bytes 정도 되는 것을 확인할 수 있습니다. 패킷이 담는 데이터의 크기에 따라 천차만별일 것입니다.

![figure 4](2016101071_%E1%84%92%E1%85%AA%E1%86%BC%E1%84%8C%E1%85%A6%E1%84%8E%E1%85%A5%E1%86%AF_TASK_4%20bc1347b0e65748899e2d81939b41d523/Untitled%207.png)

figure 4

`capture length` : 캡쳐된 프레임의 크기를 나타냅니다. 실제 프레임의 크기와 와이어샤크가 캡쳐하는 프레임의 크기가 다른지 확인하기 위해선 해당 데이터를 확인하면 됩니다. 일반적으로는 프레임 크기와 동일하게 보여집니다.

`frame is marked` : 와이어샤크에서 제공하는 “패킷 마킹” 기능의 활성 여부를 나타내는 플래그로, 실제 프레임 헤더에 포함되는 데이터가 아닙니다. 사용자가 와이어샤크를 통해 특정 패킷을 마킹하면 해당 플래그가 활성화됩니다.

![Untitled](2016101071_%E1%84%92%E1%85%AA%E1%86%BC%E1%84%8C%E1%85%A6%E1%84%8E%E1%85%A5%E1%86%AF_TASK_4%20bc1347b0e65748899e2d81939b41d523/Untitled%208.png)

`frame is ignored` : 와이어샤크에서 제공하는 “패킷 무시” 기능의 활성 여부를 나타내는 플래그로, 실제 프레임 헤더에 포함되는 데이터가 아닙니다. 사용자가 와이어샤크를 통해 특정 패킷을 ignore하면 해당 플래그기 ip.addr 등의 필터를 걸어서 볼 때 보이지 않게 만들 수 있습니다.

![Untitled](2016101071_%E1%84%92%E1%85%AA%E1%86%BC%E1%84%8C%E1%85%A6%E1%84%8E%E1%85%A5%E1%86%AF_TASK_4%20bc1347b0e65748899e2d81939b41d523/Untitled%209.png)

`protocols in frame` : 각 계층에서 어떤 프로토콜을 이용하여 데이터를 구성하였는지를 나타내는 정보를 담고 있는지를 나타냅니다. 네트워크가 여러 계층 구조로 이루어져 있고, 프레임은 링크 레이어의 전송 단위이다보니 여기서 다룸으로써 전체적으로 사용된 프로토콜 구조를 이해할 수 있습니다. figure 1을 참고하면 “eth:ethertype:ip:tcp”라고 되어있는데, 이는 프레임을 구성하는 프로토콜 조합이 ethernet, IP, TCP임을 알 수 있습니다. 여기서 이더넷은 링크 레이어 프로토콜입니다.

![figure 5](2016101071_%E1%84%92%E1%85%AA%E1%86%BC%E1%84%8C%E1%85%A6%E1%84%8E%E1%85%A5%E1%86%AF_TASK_4%20bc1347b0e65748899e2d81939b41d523/Untitled%2010.png)

figure 5

이더타입은 이더넷 프레임의 내부 프로토콜을 식별하는 역할을 하고, figure 1에서는 내부 프로토콜이 IP 프로토콜임을 의미합니다.

또한 IP 패킷 내부에 TCP 프로토콜이 지정되어 있다는 건, 해당 IP패킷이 TCP를 사용하여 데이터를 신뢰성 있게 전송하고 있음을 나타내고 있습니다.

`coloring rule name` : 와이어샤크가 패킷을 가시화할 때 컬러링에 사용하는 규칙의 식별자를 의미합니다. 즉, 패킷 컬러링 규칙을 식별하는 “이름”을 나타내는 정보입니다. figure 1을 보면 tcp라고 되어 있으므로 tcp에 해당하는 규칙에 따라 컬러링을 하도록 나타내고 있습니다.

`coloring rule string` : 와이어샤크의 패킷 컬러링 규칙 내용을 나타내는 문자열입니다. figure 1을 보면 tcp라고 되어 있으므로 tcp에 해당하는 규칙에 따라 컬러링을 하도록 나타내고 있습니다.

### Ethernet

![Untitled](2016101071_%E1%84%92%E1%85%AA%E1%86%BC%E1%84%8C%E1%85%A6%E1%84%8E%E1%85%A5%E1%86%AF_TASK_4%20bc1347b0e65748899e2d81939b41d523/Untitled%2011.png)

`destination` : 도착지의 MAC주소를 나타냅니다. 위 사진에서 볼 수 있는 Address와 LG bit, 그리고 IG bit에 대해 설명하면 다음과 같습니다.

- Address : MAC주소를 나타냅니다. 인텔사의 네트워크 인터페이스 카드임을 나타내는 식별자(IntelCor_8f:55:b1)와 함께 실제 MAC주소(e8:f4:08:8f:55:b1)가 혼합된 형태를 띄고 있음을 알 수 있습니다.
- LG bit : 이더넷 프레임의 MAC주소에서 나오는, 생산 당시 기존에 부여되었던 주소를 의미합니다. 0으로 설정되어 있으면 전 세계적으로 해당 MAC 주소가 고유한 식별자로서 사용될 수 있음을 의미하며, 만약 1로 설정되어 있다면 특정 군집 내에서만 사용할 수 있도록 할당된 주소임을 의미합니다. 위 패킷에서는 destination과 source 모두에서 0이므로 두 MAC 주소 모두 전 세계에서 고유한 식별자로서 사용될 수 있음을 의미합니다.
- IG bit : 이더넷 프레임의 MAC주소가 독립적인(유니캐스트) 주소인지, 아니면 특정 군집을 가리키는 주소인지를 나타냅니다. 만약 0이라면 유니캐스트 MAC 주소라고 나타낸 것이고, 1이라면 특정 그룹을 가리키는 주소임을 의미합니다. 위 사진에서는 source와 destination 모두 0으로 나타나 있으므로 두 MAC 주소 모두 유니캐스트 주소임을 알 수 있습니다.

`source` : 출발지의 MAC 주소를 나타냅니다.  상세 내용은 destination과 동일하므로 생략하겠습니다.

`type` : 상위 계층 헤더로 사용된 프로토콜의 종류를 나타냅니다. figure 1의 경우에서는 IPv4(0x0800)라고 나타나 있는 것으로 보아, 네트워크 레이어에서 IP 프로토콜이 사용되고 있는 것임을 알 수 있습니다.

![Untitled](2016101071_%E1%84%92%E1%85%AA%E1%86%BC%E1%84%8C%E1%85%A6%E1%84%8E%E1%85%A5%E1%86%AF_TASK_4%20bc1347b0e65748899e2d81939b41d523/Untitled%2012.png)

`padding` : 이더넷 프레임은 최소 크기(64byte)를 가져야 하기 때문에 만약 전송하려는 데이터/페이로드 크기가 이더넷 프레임의 최소 크기를 충족하지 못할 경우  프레임의 최소 크기까지 0을 채워 추가 조정하는 여분의 비트가 존재하며, 이를 패딩 비트라고 합니다. 즉, 항상 있는 값이 아닙니다.  한번 패킷을 확인해보면 다음과 같습니다.

![Untitled](2016101071_%E1%84%92%E1%85%AA%E1%86%BC%E1%84%8C%E1%85%A6%E1%84%8E%E1%85%A5%E1%86%AF_TASK_4%20bc1347b0e65748899e2d81939b41d523/Untitled%2013.png)

위 사진으로 보아 이더넷 프레임 중에서 이더넷 헤더를 구성하는 영역은 위와 같고,

![Untitled](2016101071_%E1%84%92%E1%85%AA%E1%86%BC%E1%84%8C%E1%85%A6%E1%84%8E%E1%85%A5%E1%86%AF_TASK_4%20bc1347b0e65748899e2d81939b41d523/Untitled%2014.png)

IP프로토콜 데이터그램은 이더넷 프레임에서 위 영역을 차지하고 있습니다.

![Untitled](2016101071_%E1%84%92%E1%85%AA%E1%86%BC%E1%84%8C%E1%85%A6%E1%84%8E%E1%85%A5%E1%86%AF_TASK_4%20bc1347b0e65748899e2d81939b41d523/Untitled%2015.png)

그리고 TCP 프로토콜 세그먼트의 크기는 위와 같습니다. 하지만 여기까지만 구성된다면 이더넷 프레임은 64바이트를 채우지 못해 최소 크기를 충족할 수 없습니다.

![Untitled](2016101071_%E1%84%92%E1%85%AA%E1%86%BC%E1%84%8C%E1%85%A6%E1%84%8E%E1%85%A5%E1%86%AF_TASK_4%20bc1347b0e65748899e2d81939b41d523/Untitled%2016.png)

따라서 이렇게 이더넷 프레임에 패딩 필드값을 이용하여 최소 크기를 맞춰주는 것입니다.

`FCS` : 이더넷 프레임은 FCS(Frame check sequence) 필드가 있어야 하는데, 위 패킷에 어떤 문제가 있어 제대로 보이지 않는 것 같아, 그 위 패킷을 열어보았더니 다음과 같이 FCS 필드가 확인되어 이 것으로 분석을 해보고자 합니다. 

![Untitled](2016101071_%E1%84%92%E1%85%AA%E1%86%BC%E1%84%8C%E1%85%A6%E1%84%8E%E1%85%A5%E1%86%AF_TASK_4%20bc1347b0e65748899e2d81939b41d523/Untitled%2017.png)

이는 이더넷 프레임 데이터의 무결성 검증을 위해 사용되는 값으로, 링크 레이어의 역할 중 하나인 오류 검출을 위한 필드입니다. 이 값은 프레임 데이터 비트들을 계산하여 생성되며, CRC(Cyclic Redundancy Check) 알고리즘을 통해 계산되어 송신자의 계산값과 수신자의 계산값이 일치하는지 여부를 통해 데이터의 무결성을 검증하게 됩니다. 만약 이 과정에서 값이 일치하지 않는다면 해당 프레임은 폐기됩니다.

참고:

[Wireshark 데이터링크 계층(Data link layer) 분석](https://coding-everyday.tistory.com/25)

[Layer 2 데이터 링크 계층의 프로토콜](https://rohal45.tistory.com/2)

[이더넷 프레임(Ethernet Frame)의 개념](https://m.blog.naver.com/PostView.naver?blogId=joo1020_kr&logNo=221471086900&categoryNo=29&proxyReferer=)

[와이어샤크(WireShark) - DataLink Layer [Frame]분석](https://grey-hat.tistory.com/entry/와이어샤크WireShark-DataLink-Layer-Frame분석)

[와이어샤크(WireShark) - DataLink Layer [Ethernet 2] 분석](https://grey-hat.tistory.com/entry/와이어샤크WireShark-DataLink-Layer-Ethernet-2-분석?category=866432)