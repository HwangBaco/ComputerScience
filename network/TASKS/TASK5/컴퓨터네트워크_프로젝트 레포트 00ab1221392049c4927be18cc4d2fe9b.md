# 컴퓨터네트워크_프로젝트 레포트

# 웹 서버에 대한 설명

---

### 만든 목적이 무엇인가? 무엇을 작동하게 하는 서버인가?

이번 프로젝트에서는 스프링 프레임워크를 활용하여 **(1) 채팅방 생성, (2) 여러명 동시 채팅 기능,** 그리고 **(3) 이미지를 서버에 첨부**할 수 있는 기능을 구현하고자 하였습니다. 또한 서버를 HTTPS를 통해 접근하게끔 구현하여 TLS 패킷에 대해서도 알아볼 수 있게끔 준비하였습니다.

### 클라리언트와 서버의 작동 시나리오는 무엇인가?

1. 서버 컴퓨터 사용자가 ngrok 터널링 툴을 이용하여 로컬 8080 포트에 대해 http 접근을 하는 요청을 ngrok 프록시 서버로 리다이렉트 하게끔 설정합니다. (ngrok은 리버스 프록시를 수행하는 프록시 서버를 사용할 수 있는 터널링 툴로써, 별도로 포트포워딩 등의 작업을 수행하지 않고도 로컬 환경을 외부에서 접속할 수 있게 해주는 도구입니다.)
2. 서버 측에서 스프링 어플리케이션을 실행하여 로컬 환경 8080 포트에 구현한 채팅 서버를 실행시킵니다.
    
    ![Untitled](%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3_%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8C%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3%20%E1%84%85%E1%85%A6%E1%84%91%E1%85%A9%E1%84%90%E1%85%B3%2000ab1221392049c4927be18cc4d2fe9b/Untitled.png)
    
3. ngrok에서 생성한 도메인을 접속하고자 하는 사람들에게 공유하고, 다같이 서버에 접속하여 채팅을 수행합니다.
    
    ![Untitled](%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3_%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8C%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3%20%E1%84%85%E1%85%A6%E1%84%91%E1%85%A9%E1%84%90%E1%85%B3%2000ab1221392049c4927be18cc4d2fe9b/Untitled%201.png)
    
4. 참여자는 서버에 이미지를 업로드하고 이를 GET 방식을 통해 조회할 수 있습니다.

![Untitled](%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3_%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8C%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3%20%E1%84%85%E1%85%A6%E1%84%91%E1%85%A9%E1%84%90%E1%85%B3%2000ab1221392049c4927be18cc4d2fe9b/Untitled%202.png)

![Untitled](%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3_%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8C%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3%20%E1%84%85%E1%85%A6%E1%84%91%E1%85%A9%E1%84%90%E1%85%B3%2000ab1221392049c4927be18cc4d2fe9b/Untitled%203.png)

### 어플리케이션 사용법

1. git pull origin master를 통해 깃 레포에서 코드를 받습니다.
2. 인텔리제이 등의 에디터를 이용하여 `ImageUploadSpringApplication`을 실행(Main을 실행)하면 스프링 어플리케이션이 실행됩니다. 이후 http://localhost:8080으로 브라우저에 접속하면 구현된 웹 서버를 로컬에서 확인할 수 있습니다.

![실행하였을 때 위와 같이 로그 맨 마지막에 Started ImageUpload…Application 이 뜬다면 성공입니다.](%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3_%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8C%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3%20%E1%84%85%E1%85%A6%E1%84%91%E1%85%A9%E1%84%90%E1%85%B3%2000ab1221392049c4927be18cc4d2fe9b/Untitled%204.png)

실행하였을 때 위와 같이 로그 맨 마지막에 Started ImageUpload…Application 이 뜬다면 성공입니다.

<aside>
<img src="%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3_%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8C%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3%20%E1%84%85%E1%85%A6%E1%84%91%E1%85%A9%E1%84%90%E1%85%B3%2000ab1221392049c4927be18cc4d2fe9b/25231.png" alt="%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3_%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8C%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3%20%E1%84%85%E1%85%A6%E1%84%91%E1%85%A9%E1%84%90%E1%85%B3%2000ab1221392049c4927be18cc4d2fe9b/25231.png" width="40px" /> 깃허브 주소 : [https://github.com/rlawhdtjd/ImageUpload-spring](https://github.com/rlawhdtjd/ImageUpload-spring)

</aside>

# 패킷의 캡쳐 및 분석

---

> 패킷 분석은 노트북 환경에서 와이어샤크를 이용하여 패킷을 캡쳐한 것을 바탕으로 구성되었습니다. 아울러 원활한 패킷 캡쳐를 위해 실습을 여러번 시도해서 조금씩 다른 캡쳐 이미지가 사용될 수 있습니다. 동일한 시나리오를 여러번 수행한 결과이니 참고해 주시길 바랍니다.
> 

## 유저 시나리오

실행했던 시나리오는 다음과 같습니다.

1. 모바일 사용자가 외부에서 도메인 링크를 타고 서비스에 접속합니다.
2. 모바일 사용자가 `http chat` 채팅방을 개설합니다.
3. 모바일 사용자가 먼저 채팅방에 입장합니다.
4. 노트북 사용자가 도메인 링크를 타고 서비스에 접속합니다.
5. 노트북 사용자가 채팅방에 입장합니다.
6. 모바일 사용자가 “황제철”, “김민수”, “김종성”, “홍지승”, 박규현” 과 같이 팀원 이름을 나열하여 입력합니다.
7. 노트북 사용자가 파일을 선택하여 이미지 업로드를 하고, 별도로 구성되어 있는 이미지 확인 페이지에서 이미지를 확인합니다.
8. 뒤로 가기를 누른 뒤에 “안녕”, “테스트” 문자열을 노트북에서 입력하여 채팅을 전송합니다. 

![Untitled](%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3_%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8C%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3%20%E1%84%85%E1%85%A6%E1%84%91%E1%85%A9%E1%84%90%E1%85%B3%2000ab1221392049c4927be18cc4d2fe9b/Untitled%205.png)

## 도메인 접속

노트북은 IP 주소가 아닌 도메인 이름으로 된 하이퍼링크를 타고 해당 웹 서버에 접속하므로, DNS에 먼저 IP 주소를 확인해야 합니다.

![Untitled](%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3_%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8C%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3%20%E1%84%85%E1%85%A6%E1%84%91%E1%85%A9%E1%84%90%E1%85%B3%2000ab1221392049c4927be18cc4d2fe9b/Untitled%206.png)

이는 DNS에 standard query를 날려서 접속을 요청한 도메인의 IP 주소를 알아내고자 하는 모습이 캡쳐된 화면이며, 패킷 내 DNS 쿼리의 내용을 확인하면 요청했던 도메인 이름의 ngrok free app이라는 TLD(Top Level Domain)에 대하여 묻고 있는 것을 알 수 있습니다.

DNS의 IP주소와 접속 도메인의 IP주소가 어느 주소인지 더욱 정확히 알아내기 위해 윈도우 터미널에서 nslookup을 통해 확인해 보았습니다.

![Untitled](%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3_%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8C%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3%20%E1%84%85%E1%85%A6%E1%84%91%E1%85%A9%E1%84%90%E1%85%B3%2000ab1221392049c4927be18cc4d2fe9b/Untitled%207.png)

위의 DNS 서버 IP 주소는 UnKnown으로 되어있지만, 반복적으로 알아보니 DNS의 CNAME이 `bns1.hananet.net`으로 확인되었으며, 이는 현재 실행 환경의 AP인 SK 브로드밴드의 DNS인 것으로 확인되었습니다. 

![Untitled](%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3_%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8C%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3%20%E1%84%85%E1%85%A6%E1%84%91%E1%85%A9%E1%84%90%E1%85%B3%2000ab1221392049c4927be18cc4d2fe9b/Untitled%208.png)

아울러 로컬에 실행되는 서버를 리버스 프록시를 통해 간단하게 외부에서 접속할 수 있도록 `ngrok`이라는 소프트웨어를 사용하였는데, 여러 IP 주소가 다이나믹하게 할당되어, 여러 IP 주소가 잡히는 것을 확인할 수 있었습니다.

추측컨데, `nslookup`으로 알아낸 정보에 따라 보자면, ngrok이 할당하는 호스트 주소 범위가 18.176.0.0 ~ 18.177.255.255으로 보이므로, 당해 네트워크 `prefix`가 /15인 것으로 보입니다. 시시각각으로 다이나믹하게 할당되는 주소를 매번 nslookup으로 추적할 수 없으므로, 위 범위를 바탕으로 와이어샤크 패킷을 분석하였습니다.

다시 DNS 패킷부터 분석을 이어나가 보겠습니다.

![Untitled](%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3_%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8C%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3%20%E1%84%85%E1%85%A6%E1%84%91%E1%85%A9%E1%84%90%E1%85%B3%2000ab1221392049c4927be18cc4d2fe9b/Untitled%209.png)

DNS 응답을 확인해보면 위에서 확인했던 것처, 사용한 터널링 도구인 ngrok이 AWS DNS를 이용하여 IP주소를 알려주고 있고, Data center network방식으로 이루어져 있어 프록시 서버에 다이나믹하게 IP 주소를 할당한다는 것을 알 수 있었습니다.

## TCP 3-way handshake

서버 접속을 위한 IP 주소를 알았으니, 이제 노트북(클라이언트)은 서버와의 신뢰성 있는 HTTP 통신을 위해 TCP 연결 수립을 진행해야 합니다. 이에 사용퇴는 transport layer 프로토콜인 TCP는 SYN, SYN&ACK, ACK순으로 구성되는 3-way handshake를 거쳐 연결을 수립합니다.

- SYN : 클라이언트가 서버에 접속을 요청하는 패킷입니다. 이 패킷에는 송/수신자 모두의 IP주소, 포트 번호, 시퀸스 번호 등이 포함됩니다.
- SYN & ACK : 서버가 클라이언트의 접속 요청에 대한 응답과 함께 서버 또한 클라이언트와의 연결을 요청하는 패킷입니다.
- ACK : 클라이언트가 서버의 연결 요청(SYN)에 대한 수락의 의미로 보내는 패킷입니다.

![Untitled](%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3_%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8C%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3%20%E1%84%85%E1%85%A6%E1%84%91%E1%85%A9%E1%84%90%E1%85%B3%2000ab1221392049c4927be18cc4d2fe9b/Untitled%2010.png)

![Untitled](%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3_%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8C%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3%20%E1%84%85%E1%85%A6%E1%84%91%E1%85%A9%E1%84%90%E1%85%B3%2000ab1221392049c4927be18cc4d2fe9b/Untitled%2011.png)

이 때, 포트 번호가 443으로 들어가는 것을 보아, 해당 서버는 HTTPS이며, HTTPS 또한 TCP 기반으로 운영되는 프로토콜이기에 TLS 핸드셰이크 전에 먼저 TCP 연결을 수립하는 모습이 담긴 것을 확인할 수 있습니다.

## TLS handshake

> ngrok은 TLS 버전 중에서도 TLS 1.3을 위주로 서비스를 제공하고 있었습니다. 따라서 TLS 1.3 중심으로 설명을 이어가겠습니다.
> 

TLS 1.3에서는 Client Hello →Server Hello, Change Cipher Spec, Encrypted Extensions, Finished → Change Cipher Spec, Finished 3단계로 핸드쉐이크를 수행합니다. 이는 암호화 알고리즘을 결정하고 데이터를 암호화할 대칭키 전달을 하는 과정으로 이루어집니다.

![<TLS 1.2와 TLS 1.3 비교 (출처: [https://livvy.byb.kr/posts/hello-tls-1-3/](https://livvy.byb.kr/posts/hello-tls-1-3/))>](%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3_%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8C%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3%20%E1%84%85%E1%85%A6%E1%84%91%E1%85%A9%E1%84%90%E1%85%B3%2000ab1221392049c4927be18cc4d2fe9b/Untitled%2012.png)

<TLS 1.2와 TLS 1.3 비교 (출처: [https://livvy.byb.kr/posts/hello-tls-1-3/](https://livvy.byb.kr/posts/hello-tls-1-3/))>

**Client Hello**는 Client가 Server에 TLS 연결을 착수할 때 전송하는 패킷이며, 이에는 Client가 지원하는 암호화 알고리즘, 암호화 방식등, 세션 ID, 공개키들(key share)을 포함하여 패킷을 서버에 전송합니다.

**Server Hello**는 (TLS 1.3 기준) 서버가 수령한 Client Hello에 대해 서명(signature)을 생성하여 Server Hello에 담아 클라이언트에 전송합니다. 클라이언트는 이후 자신이 전송한 데이터에 대하여 서명을 생성하고, 서버가 보내준 서명을 비교하여 서버가 올바르게 수신을 하였는지를 체크함으로써 에러 감지를 수행합니다. 아울러, 서버는 Server Hello 단계에서 Application Data가 같이 확인되는 것을 볼 수 있는데, 이는 Client Hello때 share된 Key를 이용하여 서버가 Application Data를 통해 암호화된 Certificate을 전송하는 것입니다.

이후 클라이언트는 **Finished** 패킷과 동시에 Application Data를 바로 통신하면서 더욱 빠르게 암호화된 통신을 수행합니다.

위에서 확인했던 TLS 1.3 통신을 캡쳐된 패킷에서 확인해 보겠습니다.

![Untitled](%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3_%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8C%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3%20%E1%84%85%E1%85%A6%E1%84%91%E1%85%A9%E1%84%90%E1%85%B3%2000ab1221392049c4927be18cc4d2fe9b/Untitled%2013.png)

아쉽게도 TLS 핸드셰이크가 이루어지는 패킷 중 Server Hello만 정상적으로 캡쳐되었습니다. 추정컨데, 뒤에 씹힌 TLS 1.3패킷이 Finished 패킷이 아닐까 추측하고 있고, Client Hello 패킷은 누락된 것으로 보입니다. ngrok이 일본 서버를 활용하고 있어 latency가 어느정도 발생하기에 생긴 현상으로 추정됩니다…

일단 Server Hello 패킷을 좀 더 자세히 확인해 보겠습니다.

![Untitled](%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3_%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8C%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3%20%E1%84%85%E1%85%A6%E1%84%91%E1%85%A9%E1%84%90%E1%85%B3%2000ab1221392049c4927be18cc4d2fe9b/Untitled%2014.png)

> 위 패킷의 TLS 헤더의 버전에 TLS 1.2라고 표기되어 있는 이유는, 헤더에 TLS 1.3을 의미하는 0x0304를 넣으면 기존에는 존재하지 않았던 버전이기 때문에, 잘못된 패킷이나 공격으로 감지하거나, 제대로 동작하지 않는 일이 발생하기 때문입니. 이 문제를 해결하기 위해서, TLS 1.3은 기존의 버전을 나타내는 값에는 TLS 1.2와 같은 값을 사용하고, SupportedVersions라는 추가 확장을 통해서 자신이 지원하는 모든 버전을 명시하는 방식으로 변경했습니다.
(출처: [https://livvy.byb.kr/posts/hello-tls-1-3/](https://livvy.byb.kr/posts/hello-tls-1-3/))
> 

캡쳐된 Server Hello 패킷은 핸드셰이크 프로토콜, Change Cipher Spec 프로토콜, Application Data Protocol로 이루어져 있습니다. 여기서 확인되는 것은 Server Hello 패킷을 통해 핸드셰이크 과정임을 알 수 있고, Change Cipher Spec 프로토콜은 Handshake 과정에서 데이터 암호화용 대칭키 생성이 완료되었으니, 이후부터는 이를 이용하여 데이터를 암호화하라는 신호를 의미합니다. 그리고 Application Data 프로토콜을 통해 암호화된 Certificate을 전달하고 있음을 알 수 있습니다.

## 채팅 메세지 통신 및 이미지 첨부

TCP 핸드셰이크, TLS 핸드셰이크까지 수립되었으니, 데이터 통신하는 과정을 확인해 보도록 하겠습니다. 이 과정에서 암호화된 TLS 패킷 하나를 모든 레이어 별로 전부 뜯어보는 시간을 가져보겠습니다.

채팅 메세지는 STOMP를 이용하여 구현되어 있으며, 이미지는 GET 방식으로 Binary code를 확인하는 방식으로 되어 있습니다. Application Data로 구현되어 있으므로 패킷을 면밀히 분석하면서 공부해 보겠습니다.

![Untitled](%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3_%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8C%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3%20%E1%84%85%E1%85%A6%E1%84%91%E1%85%A9%E1%84%90%E1%85%B3%2000ab1221392049c4927be18cc4d2fe9b/Untitled%2015.png)

![Untitled](%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3_%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8C%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3%20%E1%84%85%E1%85%A6%E1%84%91%E1%85%A9%E1%84%90%E1%85%B3%2000ab1221392049c4927be18cc4d2fe9b/Untitled%2016.png)

위 패킷은 시나리오 중 채팅 전송을 수행할 때 발생한 패킷 중 하나로 추정됩니다. 리버스 프록시 서버를 통해 운영되는 서비스이므로 ngrok 서버 IP 주소에서 클라이언트 컴퓨터의 사설 IP로 데이터가 전송된 것을 확인할 수 있습니다.

이제 패킷 내용을 한번 하나하나 레이어 별로 자세히 확인해 보겠습니다.

### [Transport Layer] TLS

다음은 위 패킷의 TLS 부분에 대한 분석입니다.

![Untitled](%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3_%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8C%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3%20%E1%84%85%E1%85%A6%E1%84%91%E1%85%A9%E1%84%90%E1%85%B3%2000ab1221392049c4927be18cc4d2fe9b/Untitled%2017.png)

![Untitled](%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3_%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8C%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3%20%E1%84%85%E1%85%A6%E1%84%91%E1%85%A9%E1%84%90%E1%85%B3%2000ab1221392049c4927be18cc4d2fe9b/Untitled%2018.png)

- `Opaque type` : 와이어샤크에서 이 패킷이 TLS에 대하여는 application data 프로토콜을 사용하고 있다고 일컫고 있습니다.
- `Version` : 이 패킷이 어떤 TLS 버전에 따르는지를 나타냅니다. 이는 앞서 설명된 대로, 하위 호환성을 보장하고, 정상적인 패킷임에도 TLS 1.3을 지원하지 않아 방화벽 등에 의해 필터링되는 것을 방지하기 위해 기존 버전을 나타내는 값에는 TLS 1.2와 같은 값을 헤더에 사용합니다.
- `Length` : TLS 패킷 부분의 길이를 나타냅니다.
- `Encrypted Application Data` : 이 패킷이 담고 있는 암호화된 데이터를 의미합니다. 
이를 복호화하여 심층 패킷 분석을 시도해보고자 하였지만, 외부 터널링 툴을 이용하다보니 암호화 알고리즘이나 대칭키/비대칭키에 대한 기반 정보가 없어 시도하기에 어려움을 겪었습니다. 이를 위해 내부적으로 HTTPS를 구현하려고 시도했었지만, 인증서 등의 과정을 거쳐 로컬 환경에서는 HTTPS가 원활히 수행되는 것을 확인했지만, NAT와 방화벽 인바운드 등의 여러 설정을 가능한 전부 처리했다 판단하였는데도 외부에서 로컬 서버로 접속이 되지 않아 결국 심층 패킷 분석은 실패하였습니다.

![Untitled](%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3_%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8C%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3%20%E1%84%85%E1%85%A6%E1%84%91%E1%85%A9%E1%84%90%E1%85%B3%2000ab1221392049c4927be18cc4d2fe9b/Untitled%2019.png)

![Untitled](%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3_%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8C%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3%20%E1%84%85%E1%85%A6%E1%84%91%E1%85%A9%E1%84%90%E1%85%B3%2000ab1221392049c4927be18cc4d2fe9b/Untitled%2020.png)

### [Transport Layer] TCP

Transport Layer는 TCP/IP 5계층 모델에서 프로세스 간 논리적인 연결을 담당하는 계층입니다. 이 계층의 메인 기능은 데이터의 전송과 오류 검사 및 복구입니다. 주로 사용되는 프로토콜은 TCP와 UDP입니다.

TCP는 신뢰성 있는 데이터 전송을 보장하기 위해 앞서 설명한 것 처럼 3-way handshake, 전송 계층의 PDU인 세그먼트 분할 및 재조립, 체크섬 등을 통한 오류 검사 및 복구 작업을 수행합니다. 신뢰성있는 데이터 전송을 위해 통신 간 flow control과 congestion control을 수행합니다. 이는 일반적으로 메세지 전송 등과 같이 하나하나의 데이터의 정확성이 필요한 작업에 적용됩니다. 최근에는 네트워크 성능이 워낙 향상되어서 많은 부분이 TCP로 적용되고 있습니다.

UDP는 TCP와 달리 연결을 수립하지는 않으며, 그렇기 때문에 더 빠른 전송을 수행할 수 있다는 장점이 있지만, 그만큼 더욱 패킷 유실 등의 신뢰성 있는 데이터 전송을 보장할 수 없습니다. 일반적으로 스트리밍과 같이 하나하나의 데이터 손실과 순서 보장 보다는 빠른 데이터 공급 등이 필요한 경우에 많이 사용됩니다.

다음은 위 패킷의 TCP 세그먼트에 대한 분석입니다.

![Untitled](%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3_%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8C%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3%20%E1%84%85%E1%85%A6%E1%84%91%E1%85%A9%E1%84%90%E1%85%B3%2000ab1221392049c4927be18cc4d2fe9b/Untitled%2021.png)

- `Source Port` : 해당 패킷을 송신한 장치의 포트를 의미합니다. ngrok 프록시 서버가 HTTPS 환경을 구축해 두었으므로 443 포트에서 온 것을 확인할 수 있습니다.
- `Destination Port` : 해당 패킷을 수신한 장치의 포트를 의미합니다. 여기서는 내 컴퓨터 사설 IP 주소의 3064라는 포트가 동적으로 할당되어 수신한 것을 확인할 수 있습니다.

<aside>
💡 전송 계층은 프로세스 간의 논리적 통신을 구현하므로 송/수신 포트를 헤더에 나타내어 프로세스 간 연결을 구현합니다.

</aside>

- `Sequence Number` : reliable한 통신을 위해 부여되는 고유한 숫자 값으로, TCP 세그먼트 간의 식별이 가능한 값입니다. 패킷 손실을 방지하기 위해 사용됩니다.
- `Acknowledge Number` : 다음 세그먼트를 수신할 수 있는 상태를 나타내는 번호입니다. 송신자는 이를 확인하고 이 값과 동일한 Squence Number를 가지는 패킷을 다음에 보내게 됩니다.

만약 문제가 감지된다면, 패킷을 재전송함으로써 이를 해결합니다. 이 과정에서 어떤 패킷만 재전송할지는 flow control등에서 적용되는 방법에 따릅니다.

![순서를 감지하고, 문제가 있음을 알려주는 부분](%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3_%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8C%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3%20%E1%84%85%E1%85%A6%E1%84%91%E1%85%A9%E1%84%90%E1%85%B3%2000ab1221392049c4927be18cc4d2fe9b/Untitled%2022.png)

순서를 감지하고, 문제가 있음을 알려주는 부분

![문제가 있는 패킷을 재전송하는 부분](%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3_%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8C%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3%20%E1%84%85%E1%85%A6%E1%84%91%E1%85%A9%E1%84%90%E1%85%B3%2000ab1221392049c4927be18cc4d2fe9b/Untitled%2023.png)

문제가 있는 패킷을 재전송하는 부분

<aside>
💡 위 Sequence Number와 ACK number를 이용하여 TCP는 신뢰성 있는 통신을 보장하게 됩니다.

</aside>

- `Header Length`  : TCP 헤더의 길이입니다. 필드 값이 4Bytes씩 증가하므로, 위 패킷은 5 * 4 = 20 Bytes 입니다.
- `Flags` : 6개의 비트로 구성되는 컨트롤 플래그 필드입니다. 위 캡쳐된 패킷은 PSH, ACK을 나타내고 있고, 여기서 PSH는 일반적으로 관련된 모든 데이터가 전송되었으니, 이 패킷을 받으면 데이터를 담은 버퍼를 모두 비움으로써 데이터를 즉시 어플리케이션 계층으로 전달하라는 의미입니다. 그리고 ACK은 응답 메세지임을 나타냅니다. 그 외에 URG: 긴급 요청, RST: 맺은 세션 강제 종료, SYN: 연결 요청, FIN: 세션 정상 종료 등의 FLAG 값이 있습니다.
- `payload` : 실제 전송하고자 하는 데이터가 담겨있는 부분입니다. 이는 위 패킷에서 TLS로 암호화되어 있습니다.
- `checksum` : 네트워크를 통해 전송되는 데이터의 값이 변경되었는지를 검사하는 값입니다. 데이터 전송 간의 데이터 무결성을 보장하기 위해 사용됩니다. TCP를 구성하는 헤더와 페이로드를 16비트 단위로 분할한 뒤, 그 비트 합을 구하고 1의 보수를 취함으로써 완성됩니다. 이 때 carry가 발생하는 것은 wrap around를 적용하여 계속 전부 더해줍니다. 수신자는 같은 방식으로 값을 생성한 뒤 1의 보수를 취하지 않고 체크섬을 더하여 모든 비트가 1인 경우에는 정상, 하나라도 0이 있을 경우 비정상임을 확인하는 방식으로 무결성 검증을 수행할 수 있습니다.

![출처 : [https://nogan.tistory.com/21](https://nogan.tistory.com/21)](%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3_%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8C%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3%20%E1%84%85%E1%85%A6%E1%84%91%E1%85%A9%E1%84%90%E1%85%B3%2000ab1221392049c4927be18cc4d2fe9b/Untitled%2024.png)

출처 : [https://nogan.tistory.com/21](https://nogan.tistory.com/21)

### [Network Layer] IP

네트워크 계층은 호스트와 호스트 간 논리적 연결을 담당하는 계층입니다. 네트워크 계층은 패킷을 목적지로 라우팅하는 역할을 수행하며, 이 과정에서 그 목적에 따라 link-state 알고리즘, distance vector 알고리즘이 라우팅에 적용됩니다.

네트워크 레이어에서는 인터넷 프로토콜이 가장 주로 사용되는 프로토콜이며, ICMP, ARP등의 프로토콜 또한 많이 수행됩니다.

다음은 위 패킷의 네트워크 레이어 데이터그램에 대한 분석입니다.

![Untitled](%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3_%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8C%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3%20%E1%84%85%E1%85%A6%E1%84%91%E1%85%A9%E1%84%90%E1%85%B3%2000ab1221392049c4927be18cc4d2fe9b/Untitled%2025.png)

![Untitled](%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3_%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8C%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3%20%E1%84%85%E1%85%A6%E1%84%91%E1%85%A9%E1%84%90%E1%85%B3%2000ab1221392049c4927be18cc4d2fe9b/Untitled%2026.png)

- `version` : IPv4인지 IPv6인지를 나타냅니다. 해당 패킷은 IPv4로 이루어져 있습니다.
- `header length` : IP 헤더의 크기를 나타내며, 0101이 기본값이며, 4Bytes 단위이므로 총 헤더의 길이가 20Bytes임을 나타내고 있습니다.
- `differentiated services field`는 패킷의 우선순위를 나타내며, 패킷의 서비스 품질을 지정하는 데 사용됩니다.
- `flags`는 3비트로 구성되며 패킷의 분할 상태를 나타내는 필드입니다. 이를 통해 패킷의 분할 여부를 알 수 있고, 분할된 경우 마지막 패킷인지를 확인할 수 있습니다. 이는 아래와 같은 세부 내용들로 이루어집니다.
    - `don't fragment` 는 패킷의 분할 가능 여부을 나타냅니다. 위 패킷에서는 1이므로 분할을 할 수 없음을 나타내고 있습니다. 만약 0이라면 분할이 가능합니다. 위 패킷은 이 값으로 1을 가지고 있으므로, 이 패킷이 처음이자 마지막 패킷임을 나타내고 있습니다.
    - `more fragments` 는 분할된 패킷이 더 있는지를 나타냅니다. 위 패킷에서는 0이므로 추가 조각이 없음을 나타내고 있습니다. 만약 1이라면 라우터는 더 많은 분할 패킷에 대한 확인 및 처리를 수행해야 합니다.
- `fragment offset`은 분할된 패킷 시리즈에서 현재 분할 패킷의 위치를 나타내고 있습니다. 위 패킷에서는 분할을 허용하지 않고 있으므로 offset 또한 0임을 알 수 있습니다. 만약 값이 있을 때에는 분할 패킷을 재조립할 때 이 값을 이용하여 순서를 맞추게 됩니다.
- `time to live`은 네트워크에서의 패킷 수명을 나타냅니다. 이 값은 라우터 등의 hop을 통과할 때마다 1씩 감소하며, 0이 되면 패킷은 폐기됩니다. 즉, 얼마나 많은 hop을 통과할 수 있는지를 의미하는 값으로 구성되며, 이로 인해 패킷이 네트워크 상에서 유랑하는 것을 방지합니다. ICMP와 같은 경우에는 TTL을 전략적으로 이용하여 traceroute와 같은 방법을 통해 네트워크 연결 상태를 구체적으로 파악하는 데에 사용됩니다. 위 패킷에서는 243이라는 값을 가지고 있습니다. 즉, hop을 242번 통과할 수 있다는 의미입니다.
- `protocol`은 상위 계층의 프로토콜을 알려주고 있습니다. 이 패킷은 TCP패킷을 캡쳐한 것이었으므로 위 분석 값에서도 상위 프로토콜이 TCP임을 보여주고 있습니다.
- `header checksum`은 헤더의 무결성을 체크하기 위한 값입니다. TCP 체크섬과 비슷하게, IP 데이터그램의 헤더를 16비트 단위로 쪼개어 전부 합한 값의 1의 보수를 취하여 만들어집니다. 수신자는 같은 방식으로 값을 생성한 뒤 1의 보수를 취하지 않고 체크섬을 더하여 모든 비트가 1인 경우에는 정상, 하나라도 0이 있을 경우 비정상임을 확인하는 방식으로 무결성 검증을 수행할 수 있습니다.
- `source address`은 패킷의 출발지 IP 주소를 나타냅니다. 이는 32비트의 IPv4로 구성된 주소임을 볼 수 있습니다.
- `destination address`는 패킷의 목적지 IP주소를 나타냅니다. 이 또한 32비트의 IPv4로 구성된 주소임을 볼 수 있습니다.

<aside>
💡 네트워크 레이어는 호스트 간 논리적 연결을 구현하는 계층입니다. 따라서 source address와 destination address에 IP address를 담고 있습니다.

</aside>

### [Link Layer] Ethernet

호스트나 라우터 간의 통신을 실제로 수행하기 위해 전기 신호를 쏴야 하는데, 이 전기 신호를 보내는 과정을 링크 레이어에서 맡고 있습니다. 링크 레이어에서는 MAC 주소를 바탕으로 프레임을 전송하고, 송수신 데이터의 무결성을 CRC를 통해 검증합니다. 라우팅은 네트워크 계층에서 수행하므로, 링크 계층에서는 유/무선 링크를 통해 데이터를 전송하는 것에 집중합니다. 데이터그램을 프레임으로 만들고, 에러 감지와 recover를 수행합니다.

> 보고서를 작성하다가 알게 된 사실로, TCP/IP 5계층은 원래 4계층인 Application, Transport, Network, Link 계층으로 발표되었다가, 이후 Physical 레이어가 추가된 것이라고 하는 것을 알게 되었습니다. 역시나 공부할 때에 Link 계층과 Physical 계층이 논리적으로 매우 가까이 있다고 생각했는데, 기존에는 하나로 묶이는 개념이었다고 하니 신기하였습니다.
> 

가장 일반적으로 사용되는 프로토콜이 LAN을 구현하는 이더넷이며, 두 컴퓨터 간 비동기 직렬 링크를 사용하는 PPP(point-to-point)방식 등도 있습니다.

![Untitled](%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3_%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8C%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3%20%E1%84%85%E1%85%A6%E1%84%91%E1%85%A9%E1%84%90%E1%85%B3%2000ab1221392049c4927be18cc4d2fe9b/Untitled%2027.png)

![Untitled](%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3_%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8C%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3%20%E1%84%85%E1%85%A6%E1%84%91%E1%85%A9%E1%84%90%E1%85%B3%2000ab1221392049c4927be18cc4d2fe9b/Untitled%2028.png)

- `destination` : 수신 노드의 MAC 주소를 의미합니다. 여기서는 링크 계층에서의 송수신 주소를 나타내고 있으므로, 도착지가 패킷 캡쳐를 하는 노트북의 MAC 주소임을 확인할 수 있습니다.
    
    ![Untitled](%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3_%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8C%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3%20%E1%84%85%E1%85%A6%E1%84%91%E1%85%A9%E1%84%90%E1%85%B3%2000ab1221392049c4927be18cc4d2fe9b/Untitled%2029.png)
    
- `source` : 송신 노드의 MAC 주소를 의미합니다. 여기서는 링크 계층에서의 송수신 주소를 나타내고 있으므로, 송신지가 패킷 캡쳐를 하는 노트북이 속한 서브넷의 AP인 공유기의 MAC 주소임을 알 수 있습니다. (앞의 HFR은 제조자인 에치에프알의 식별기호임을 알 수 있습니다.)
    
    ![Untitled](%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3_%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8C%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3%20%E1%84%85%E1%85%A6%E1%84%91%E1%85%A9%E1%84%90%E1%85%B3%2000ab1221392049c4927be18cc4d2fe9b/Untitled%2030.png)
    
    <aside>
    💡 링크 계층은 노드와 노드 간 논리적 통신을 담당하므로, 송수신 노드의 MAC 주소 정보를 헤더에 담고 있습니다.
    
    </aside>
    
- `type` : 상위 네트워크 계층에서 어떤 프로토콜이 사용되었는지를 나타냅니다. 이 패킷은 IPv4를 사용하는 패킷이었으므로 해당 값이 나타나 있습니다.
- `Frame check sequence` : error detection을 위한 CRC 알고리즘 값을 나타내고 있습니다. 이는 이 프레임의 16진수 값인 e8 f4 08 8f 55 b1 00 23 aa 43 58 d8 08 00을 이진법으로 변환한 뒤 generator를 이용하여 계산한 결과가 be ac fd 74임을 나타내고 있습니다. 이 값이 헤더에 같이 붙어있는 게 아니라 뒤에 trailer로 붙어있는 이유는, 전송 과정에서 무결성 검증을 수행할 때 다시 FCS 비트를 찾는 과정을 수행하는 오버헤드를 최소화하기 위해서 프레임의 뒤에 배치시키는 것이 그 하나의 이유가 됩니다.

이렇게 클라이언트와 서버 간의 많은 데이터 전송 과정은 그 전송 패킷이 TCP/IP의 5계층을 거치며, 그 크기에 따라 쪼개지기도 하고, 각 계층의 헤더로 감싸지면서 무결성 검증을 위한 장치가 계속 적용되는 등의 과정을 거칩니다. 통신 과정에서 레이어를 나누는 이유는, 각 계층을 논리적으로 분리함으로써 역할이 분리된 것에 따라 독립적으로 작업을 수행하고, 문제가 발생하였을 때 어떤 계층에서 발생하는지를 파악하여 네트워크 이슈를 더욱 빠르게 파악 및 해결할 수 있기 때문입니다.

## 그 외 패킷들

이제부터는 시나리오의 어느 과정에서 발생한 패킷인지 불분명하지만, 관련 있게 발생한 패킷을 분석해 보겠습니다.

### [Network Layer] ARP

ARP는 네트워크 레이어에서 호스트가 수신한 데이터그램을 확인할 때, 헤더에 있는 목적지 IP주소에 매핑되는 MAC주소 정보가 없을 경우 사용하는 프로토콜입니다. 이는

![Untitled](%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3_%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8C%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3%20%E1%84%85%E1%85%A6%E1%84%91%E1%85%A9%E1%84%90%E1%85%B3%2000ab1221392049c4927be18cc4d2fe9b/Untitled%2031.png)

broadcast를 통해 해당 IP 주소에 해당하는 물리 주소를 모두에게 요청하여, 알고 있는 네트워크 장치가 응답해줄 수 있게끔 합니다. 실행 환경의 서브넷 AP인 HFR_43:58:D8에서 브로드캐스트를 하였기에 이 노트북 또한 수신을 하게 된 것입니다.

Target MAC 주소는 모르고 있기에 FF:FF:FF:FF:FF:FF로 브로드캐스트를 건 것을 알 수 있고, 해당 MAC 주소와 매핑되어야 하는 Target IP 주소를 알려줌으로써 해당 정보에 대해 알고 있는 장치의 응답을 요청하고 있습니다.

추가로, 이는 이더넷 프레임의 최소 사이즈인 64바이트를 채우지 못하여 패딩 값이 존재하는 것을 확인할 수 있습니다.

### [Application Layer] NBNS

NetBIOS 네임 서비 프로토콜이며, 이론적인 설계상으로는 이는 네트워크에 연결된 다른 컴퓨터 상호간의 이름이 충돌되지 않도록 도와주는 역할을 한다고 합니다. 이는 DNS와 같은 역할을 하는 프로토콜이라고 하는데, IPv6를 지원하지는 못한다고 합니다.

![Untitled](%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3_%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8C%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3%20%E1%84%85%E1%85%A6%E1%84%91%E1%85%A9%E1%84%90%E1%85%B3%2000ab1221392049c4927be18cc4d2fe9b/Untitled%2032.png)

내 사설 IP 주소에서 서브넷 영역인 192.168.35.0 ~ 192.168.35.255/16의 가장 마지막 주소로 보내졌다. 이 주소는 네트워크 브로드캐스트 주소라고 합니다. (출처: [https://ko.ipshu.com/ip_d_list/192.168.35](https://ko.ipshu.com/ip_d_list/192.168.35)) 이는 DNS와 같이 UDP를 사용하는데, 그 사용 포트가 137로 설정되어 있습니다. 근데 이 패킷이 스푸핑에 노출되어 있는 패킷이라 하여, 이를 방지하기 위해 일반적으로 방화벽 설정을 할 때 UDP 137번 포트를 막아버리는 방법을 적용한다고 합니다.

### [Network Layer] ICMPv6

ICMP는 네트워크 계층에서 수행되는 프로토콜로, 기본적으로 IPv4에서는 ICMP라는 이름으로, IPv6에서는 ICMPv6로 사용됩니다. “type + code + description”으로 이루어진 datagram 메세지를 통해 error reporting을 위해 사용되며, ping을 사용하여 서버와의 통신 상태를 ㅌ체크하기도 하고, traceroute를 이용하여 네트워크 상태를 분석한다.

![Untitled](%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3_%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8C%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3%20%E1%84%85%E1%85%A6%E1%84%91%E1%85%A9%E1%84%90%E1%85%B3%2000ab1221392049c4927be18cc4d2fe9b/Untitled%2033.png)

위 패킷을 살펴보면 Source가 Apple이라고 되어있는 것을 볼 수 있다. 이는 채팅 시나리오를 수행할 때 모바일 디바이스를 iPhone을 사용했기 때문이며, destination MAC 주소로 수신하는 노트북의 MAC 주소가 찍혀있는 것을 볼 수 있다.
패킷을 살펴보면 Router Solicitation이라고 되어있는 것을 볼 수 있는데, 이는 ICMPv6에서 수행되는 기능으로 Router Discovery를 하기 위해 사용하는 패킷임을 나타내고 있고, DHCPv6를 통해서 prefix를 받아와서 global IP를 설정할 때 사용된다. 즉, 아이폰이 노트북을 거쳐서 외부 IP 주소를 얻는 과정에서 발생한 패킷임을 알 수 있다.

# 조원 점수 부여

---

### 총점 : 40점 (최대 12, 최소 7)

모든 인원들이 각자 맡은 임무를 잘 수행해 주었기에 원활하게 프로젝트를 마칠 수 있었습니다. 따라서 우열을 구태여 가릴 필요는 없다고 생각합니다.

홍지승 : 10

박규현 : 10

김민수 : 10

김종성 : 10