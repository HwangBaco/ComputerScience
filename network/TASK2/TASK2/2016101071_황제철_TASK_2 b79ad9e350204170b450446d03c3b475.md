# 2016101071_황제철_TASK_2

## 주제 : HTTP와 TCP 패킷 분석하기

---

- web server를 하나 선정하여 browser로 접속할 때 오가는 패킷을 wireshark로 캡처
- application layer - HTTP, Transport layer - TCP 패킷 분석

## 진행 방법

---

1. Wireshark를 실행, 캡처 시작
2. Browser로 web server를 접속, 정보검색, 종료
3. 캡처 종료 및 캡처 내용을 저장 (*.pcapng) // 이는 추후에도 사용되니 저장 필수
4. 캡처 내용에는 많은 패킷이 함께 들어 있으므로 서버와 관련된 패킷만 필터링하여 분석

*** 서버의 주소를 알기 위해서는 `nslookup`을 사용

![Untitled](2016101071_%E1%84%92%E1%85%AA%E1%86%BC%E1%84%8C%E1%85%A6%E1%84%8E%E1%85%A5%E1%86%AF_TASK_2%20b79ad9e350204170b450446d03c3b475/Untitled.png)

## 진행 내용

---

1. `nslookup`을 이용하여 lms.kau.ac.kr에 대한 ip 주소를 얻어냅니다.
    
    ![Untitled](2016101071_%E1%84%92%E1%85%AA%E1%86%BC%E1%84%8C%E1%85%A6%E1%84%8E%E1%85%A5%E1%86%AF_TASK_2%20b79ad9e350204170b450446d03c3b475/Untitled%201.png)
    
2. 위 정보에 따라 와이어샤크의 필터를 `ip.addr==210.220.163.82`와 `ip.addr==203.253.150.112` 로 설정하였습니다.
3. `lms.kau.ac.kr`에 접속한 뒤, 이것 저것 접근해보고, 입력해보며 어떤 패킷이 오가는지 확인합니다.

## 패킷 흐름 예상

---

1. 얻어낸 ip 주소로 접근하여 TCP 연결을 위한 3-way handshake 패킷을 보낼 것입니다.(SYN, SYN-ACK, ACK)
2. 그 다음엔 HTTPS이기 때문에 TLS 패킷을 주고 받으면서 연결을 수립할 것입니다.
3. 그리고 나선 HTTP 통신을 통해 데이터를 요청하고 받을 것입니다.
4. 이후에는 4-way handshake를 통해 연결을 종료할 것입니다.(FIN-ACK, ACK)

*** 위 과정들은 모두 HTTPS를 대상으로 하므로 서버 ip 주소의 443포트와 통신할 것입니다.

*** 이유를 모르겠지만, 확인된 DNS 주소로 필터를 걸고 항공대 LMS의 도메인 이름으로 접근을 하였으나, 관련되는 패킷을 검출할 수 없었습니다. 따라서 DNS 관련 패킷은 별도로 다른 도메인을 위한 통신에 대하여 확인해 보았습니다. 그 외에 확인해보고 싶었던 내용에 대해서도 고정된 서버에 대한 정보가 아닌 다른 서버에 대한 패킷으로 확인해보았습니다.

## 패킷 흐름 분석 내용

---

1. 가장 먼저 DNS 서버와 주고받는 패킷을 분석하기 위해 `ip.addr==210.220.163.82` 로 설정하고 패킷을 확인하였습니다. 항공대 LMS의 경우 DNS 서버와의 통신 방식이 UDP가 아닌 TCP로 되어 있어서 3-way handshake를 위한 패킷이 확인되는 것을 볼 수 있습니다.
    
    ![Untitled](2016101071_%E1%84%92%E1%85%AA%E1%86%BC%E1%84%8C%E1%85%A6%E1%84%8E%E1%85%A5%E1%86%AF_TASK_2%20b79ad9e350204170b450446d03c3b475/Untitled%202.png)
    
    우선은, DNS관련 패킷을 제외하고 TCP 통신을 위한 연결 수립을 보겠습니다. 로컬 포트 두 개를 이용하여 엑세스를 요청하는 것으로 보이고, 두 포트 모두에게 3-way handshake를 수립하는 과정에서 48725포트에 대한 `SYN,ACK` 패킷이 먼저 와서 해당 연결이 먼저 수립되고 DNS 서버에 쿼리를 먼저 날리게 되는 것을 볼 수 있습니다. 이후 48726포트에 대한 패킷이 도착하고 해당 연결이 마무리되는 것을 확인할 수 있습니다. 이처럼 거의 동시에 패킷을 전송하여도, 도착하는 과정에서는 그 시간차가 발생하는 것을 알 수 있습니다.
    
    하지만 너무 다양한 DNS 쿼리 패킷이 존재하여 어떤 패킷이 항공대 LMS 접근만을 위한 패킷인지 확실하지 않았습니다. 그래도 익숙한 패킷들이 있어 한번 확인해 보았습니다.
    
    ![Untitled](2016101071_%E1%84%92%E1%85%AA%E1%86%BC%E1%84%8C%E1%85%A6%E1%84%8E%E1%85%A5%E1%86%AF_TASK_2%20b79ad9e350204170b450446d03c3b475/Untitled%203.png)
    
    cloudflare와 같은 CDN, DNS 서비스를 제공하는 기업으로 쿼리를 날려서 HTTPS 접근에 대한 정보를 받는 과정을 확인할 수 있었습니다.
    
2.  `[lms.kau.ac.kr](http://lms.kau.ac.kr)` 의 ip주소로 바로 접근하여 통신하는 패킷을 확인해 보았습니다. 기본적으로 TCP 연결 설정을 위한 패킷(3-way handshake)인 SYN, SYN-ACK, ACK 패킷이 캡쳐되는 것을 확인할 수 있습니다. (이상한 것은 HTTPS에 연결을 요ㅊ80포트와 연결을 수립한다는 점인데, 이는 이후에 다시 언급하겠습니다.)
    
    ![Untitled](2016101071_%E1%84%92%E1%85%AA%E1%86%BC%E1%84%8C%E1%85%A6%E1%84%8E%E1%85%A5%E1%86%AF_TASK_2%20b79ad9e350204170b450446d03c3b475/Untitled%204.png)
    
    1. SYN : 클라이언트가 서버와 연결 수립을 요청하기 위해 보내는 패킷입니다. 초기 시퀸스 번호로 Seq=0을 담아 보내게 됩니다.
    2. SYN-ACK : 서버가 클라이언트의 연결 수립 요청에 대한 수신 양호와 함께, 연결 요청을 수락한다는 의미로 패킷을 전달합니다. 여기서도 자신의 시퀸스 번호인 Seq=0과 이전 SYN에 대한 확인의 의미로 ACK=1을 담아 보냅니다.
    3. ACK : 클라이언트가 서버의 SYN-ACK 패킷을 확인한 뒤, 연결 수립이 되었음을 확인했다고 서버에게 보내는 패킷입니다. Seq=1과 ACK=1을 담아 보냅니다.
        
        
3. 순서상 그 다음으로 확인된 패킷은 HTTP 패킷이었습니다.
    
    ![Untitled](2016101071_%E1%84%92%E1%85%AA%E1%86%BC%E1%84%8C%E1%85%A6%E1%84%8E%E1%85%A5%E1%86%AF_TASK_2%20b79ad9e350204170b450446d03c3b475/Untitled%205.png)
    
    우선 패킷에 나와있는 정보를 통해 HTTP 1.1 버전이 사용됨을 확인할 수 있습니다. 위 패킷 중 HTTP GET 패킷의 내용을 확인해보겠습니다.
    
    ![Untitled](2016101071_%E1%84%92%E1%85%AA%E1%86%BC%E1%84%8C%E1%85%A6%E1%84%8E%E1%85%A5%E1%86%AF_TASK_2%20b79ad9e350204170b450446d03c3b475/Untitled%206.png)
    
    carriage return/line feed 로 구분되어 `header`와 `body`를 확인할 수 있으며, `header` 정보에는 호스트 정보, connection 정보와 user-agent에 접근하는 브라우저 정보 등을 갖고 있는 것을 확인할 수 있습니다. 또한 `body`에는 요청한 리소스에 대한 정보를 담고 있습니다. 이를 통해 서버에 원하는 정보를 조회`GET method`할 수 있도록 요청합니다. 이에 대한 응답으로 `ACK` 패킷을 받은 뒤에 HTTP 요청에 대한 응답을 확인할 수 있습니다.
    
    ![Untitled](2016101071_%E1%84%92%E1%85%AA%E1%86%BC%E1%84%8C%E1%85%A6%E1%84%8E%E1%85%A5%E1%86%AF_TASK_2%20b79ad9e350204170b450446d03c3b475/Untitled%207.png)
    
    ![Untitled](2016101071_%E1%84%92%E1%85%AA%E1%86%BC%E1%84%8C%E1%85%A6%E1%84%8E%E1%85%A5%E1%86%AF_TASK_2%20b79ad9e350204170b450446d03c3b475/Untitled%208.png)
    
    마찬가지로 헤더와 바디로 구성된 정보를 담고 있습니다. 주목할 점은, 반환된 상태 코드가 303이라는 것입니다. 따라서 다른 페이지로 리다이렉트됩니다.
    
    따라서 FIN,ACK 과 ACK 패킷을 이용한 4-way handshake를 통해 80포트와의 TCP 연결을 종료하고, 443포트와의 연결을 수립합니다.
    
    처음 예상한 시나리오와 달리 80포트와 통신을 했었고, TLS 패킷이 보이지 않았던 것이 이상했습니다. 그런데 역시나 리다이렉트가 된 이후부터는 TLS패킷이 바로 확인되었고, 443 포트와 TCP 연결 수립을 위한 3-way handshake가 확인되었습니다.
    
    ![Untitled](2016101071_%E1%84%92%E1%85%AA%E1%86%BC%E1%84%8C%E1%85%A6%E1%84%8E%E1%85%A5%E1%86%AF_TASK_2%20b79ad9e350204170b450446d03c3b475/Untitled%209.png)
    
4. 그 다음으로 검출되는 패킷은 바로 TLS 패킷입니다. HTTP와 달리 HTTPS는 TCP 3-way handshake외에 client hello, server hello, certificate, server hello done 패킷을 교환하면서 TLS handshake라는 과정을 거치게 됩니다. 이 과정에서 각 인증서를 검증하고, 클라이언트 키를 교환하게 됩니다. TLS의 경우 이러한 별도의 handshake를 거친 뒤에 비로소 데이터를 통신합니다.
    
    ![Untitled](2016101071_%E1%84%92%E1%85%AA%E1%86%BC%E1%84%8C%E1%85%A6%E1%84%8E%E1%85%A5%E1%86%AF_TASK_2%20b79ad9e350204170b450446d03c3b475/Untitled%2010.png)
    
5. 이후에 HTTP 패킷이 확인되어야 할 것 같은데 보이지 않아 의아했습니다. 이는 자세히 보니 아래와 같이 확인할 수 있었습니다.
    
    ![Untitled](2016101071_%E1%84%92%E1%85%AA%E1%86%BC%E1%84%8C%E1%85%A6%E1%84%8E%E1%85%A5%E1%86%AF_TASK_2%20b79ad9e350204170b450446d03c3b475/Untitled%2011.png)
    
    위 패킷은 대표적으로 TLS Handshake 이후에 교환하는 data 패킷입니다. 세부 정보를 보아하니 HTTP로 교환할 데이터를 암호화하여 통신하는 모습을 확인할 수 있었습니다. 이처럼 HTTP와 달리 HTTPS는 중간에 패킷을 확인하더라도 암호화되어있어 그 내용을 쉽게 확인할 수 없습니다. 이는 HTTP로 통신할 때 그 패킷에 클라이언트가 요청한 리소스 뿐만 아니라, 사용하는 브라우저, 호스트 등 해당 패킷을 통해 각종 정보를 볼 수 있었던 것과 비교되는 포인트입니다.
    
    ***추가적으로 TLS는 1.2버전을 사용하고 있는 것을 확인할 수 있습니다.
    

1. 마지막으로 TLS와 TCP 연결을 종료하기 위해 4-way handshake를 확인할 수 있었습니다.
    
    ![Untitled](2016101071_%E1%84%92%E1%85%AA%E1%86%BC%E1%84%8C%E1%85%A6%E1%84%8E%E1%85%A5%E1%86%AF_TASK_2%20b79ad9e350204170b450446d03c3b475/Untitled%2012.png)
    
    이처럼 TCP는 FIN,ACK과 ACK 패킷을 이용한 4-way handshake를 통해 서버와의 연결을 종료합니다. 원래는 위에서 연결을 수립한 포트의 4-way handshake를 확인하고 싶었는데, 패킷이 도착하기 전에 캡쳐를 종료해버렸습니다…
    

## 추가적인 패킷 분석

---

> 여기부터는 위의 흐름 환경과 다를 수 있으나, 여러 패킷을 확인하기 위해 다각도로 패킷을 캡쳐해 보고, 그 결과를 분석한 것입니다.
> 

- TCP의 흐름 제어
    
    TCP 통신의 경우 데이터의 무결한 통신을 보장하면서, 그 성능을 최대한 보장하기 위해 흐름 제어를 수행합니다. 즉, 수신 측의 수신 정도를 고려하여 송신 측에서 전송을 제어하는 것을 의미합니다. 오늘날에는 이전의 여러 흐름 제어 기법의 단점을 개선하고 통신의 속도를 보장하는 슬라이딩 윈도우 기법을 사용합니다.
    
    ![Untitled](2016101071_%E1%84%92%E1%85%AA%E1%86%BC%E1%84%8C%E1%85%A6%E1%84%8E%E1%85%A5%E1%86%AF_TASK_2%20b79ad9e350204170b450446d03c3b475/Untitled%2013.png)
    
    ![Untitled](2016101071_%E1%84%92%E1%85%AA%E1%86%BC%E1%84%8C%E1%85%A6%E1%84%8E%E1%85%A5%E1%86%AF_TASK_2%20b79ad9e350204170b450446d03c3b475/Untitled%2014.png)
    
    위 사진에서와 같이 송신 측은 매 패킷에 대한 수신 측의 ACK을 기다리지 않고 우선 수신 측에서 설정한 윈도우의 크기에 맞춰 패킷을 계속 전송하고,  필요에 따라 윈도우 사이즈를 동적으로 조절하는 것을 확인할 수 있었습니다.
    

- DNS 패킷
    
    ![Untitled](2016101071_%E1%84%92%E1%85%AA%E1%86%BC%E1%84%8C%E1%85%A6%E1%84%8E%E1%85%A5%E1%86%AF_TASK_2%20b79ad9e350204170b450446d03c3b475/Untitled%2015.png)
    
    LMS에 접속하는 중간에 이용한 여러 서비스 중 카카오톡에 대한 DNS 패킷을 확인할 수 있었습니다. 1번의 request와 1번의 reponse로 알아내는 것을 보니 recursive 방식으로 서비스를 제공하는 DNS임을 확인할 수 있습니다. 
    
    ![Untitled](2016101071_%E1%84%92%E1%85%AA%E1%86%BC%E1%84%8C%E1%85%A6%E1%84%8E%E1%85%A5%E1%86%AF_TASK_2%20b79ad9e350204170b450446d03c3b475/Untitled%2016.png)
    
    또한 DNS는 UDP 또는 TCP 로 운영되는데, 해당 패킷의 상세 정보를 보니 UDP라고 쓰여 있음을 확인할 수 있었습니다.
    
    ![Untitled](2016101071_%E1%84%92%E1%85%AA%E1%86%BC%E1%84%8C%E1%85%A6%E1%84%8E%E1%85%A5%E1%86%AF_TASK_2%20b79ad9e350204170b450446d03c3b475/Untitled%2017.png)
    
    또한 katalk.kakao.com의 클래스가 인터넷이며 cname(canonical name)은 katalk-fo6ld96d-kgslb.com임을 알 수 있고, cname의 ip 주소가 무엇인지 명확하게 나와있음을 할 수 있습니다.
    
- UDP 패킷
    
    ![Untitled](2016101071_%E1%84%92%E1%85%AA%E1%86%BC%E1%84%8C%E1%85%A6%E1%84%8E%E1%85%A5%E1%86%AF_TASK_2%20b79ad9e350204170b450446d03c3b475/Untitled%2018.png)
    
    UDP 패킷은 TCP와 달리 확실히 그 페이로드에 데이터를 담고 그 길이만을 나타내고 있습니다. flow control과 congestion control을 수행하기에 window size부터 해서 seq, ack 등의 정보를 담는 TCP와 확실히 비교되는 모습을 보이고 있습니다.
    

## 마무리

---

이번 과제를 통해 일반적으로 우리가 어떤 웹 사이트에 접속할 때 어떤 패킷이 오가는지 피하지 않고 알아보았습니다. 처음엔 TLS가 뭔지도 잘 몰라서 HTTPS와 관련된 개념이 어색하여 HTTP로 접근하는 방법을 통해 패킷을 캡쳐할까 하였지만, 오늘날 대부분의 웹 사이트가 HTTPS로 이루어지는 만큼, 이를 이해해보는 시간을 가져봤습니다.

물론 네트워크 시간에 배울 수 있었던 HTTP 메세지의 헤더와 바디 구조, 그리고 그 내용과 더불어 TCP 통신의 3-way handshake, 4-way handshake를 확인하고, 또 DNS에 대하여도 한번 체크해보면서 지금까지 학습한 내용에 대해 좀 더 명확하게 이해할 수 있었습니다.

아쉬웠던 점은, 일부러 댓글 저장도 하고 정보 수정도 하고 했지만, HTTPS라서 메소드에 대한 정보를 명확하게 캡쳐해볼 수 없었던 점입니다.