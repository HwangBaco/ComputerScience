# Network Layer - Fragmentation, IP, Subnet

![Untitled](Network%20Layer%20-%20Fragmentation,%20IP,%20Subnet%209b748ebe6cd5469286a8469291c29568/Untitled.png)

네트워크 레이어의 구성 중,

IP Protocol은 IP 주소 체계, 데이터그램 형식, 패킷 핸들링 등이 기본적인 일이다.

단순 전송은 link layer에서 하는 일이고, 네트워크 레이어에서는 routing(길찾기)을 해줘야 한다.

![Untitled](Network%20Layer%20-%20Fragmentation,%20IP,%20Subnet%209b748ebe6cd5469286a8469291c29568/Untitled%201.png)

IP 데이터그램 포맷은 다음과 같다. 위 그림의 data 부분은 TCP와 UDP의 패킷에 해당한다. 그 겉에 정보를 더 씌워서 datagram을 형성한다.

- 데이터그램은 크기가 가변적이므로 header length 정보를 갖고 있다.
- TTL값은 라우터를 건널 떄 마다 하나씩 줄어들고, 만약 수가 전부 차감되면 네트워크 상에서 사라지게 된다.(== 유랑하는 패킷 없애는 목적)
- upper layer에 6이 있으면 data가 TCP, 17이 UDP, 1이 ICMP이다.
- fragment offset : 보내고자 하는 데이터가 너무 클 경우에는(MTU를 초과할 경우) 쪼개 보내야 하므로 해당 쪼갠 데이터그램의 offset을 알기 위한 값이다.
- header checksum으로 유효성 검증을 한다.

## Fragmentation

---

![Untitled](Network%20Layer%20-%20Fragmentation,%20IP,%20Subnet%209b748ebe6cd5469286a8469291c29568/Untitled%202.png)

데이터그램은 전송 과정에서 MTU(Maximum transfer Unit)에 따라 fragmented된다. 이후 종착지에서 재조립된다. 

![Untitled](Network%20Layer%20-%20Fragmentation,%20IP,%20Subnet%209b748ebe6cd5469286a8469291c29568/Untitled%203.png)

![Untitled](Network%20Layer%20-%20Fragmentation,%20IP,%20Subnet%209b748ebe6cd5469286a8469291c29568/Untitled%204.png)

데이터그램 조각들은 헤더 정보 중에서 identifier 기준으로 같은 데이터그램에서 쪼개진 것인지를 확인하고, fragment offset을 이용하여 순서를 맞춘다. 각 조각의 총 길이는 data만 고려할 게 아니라 header의 길이도 고려해야 한다. 헤더는 20바이트 정도 되기 때문에 최초의 4000 byte datagram은 그 데이터가 3980정도 되며, 쪼개진 데이터그램은 이를 1500 Byte라는 MTU에 맞게 헤더 20 + 데이터 1480 바이트씩 구성된 fragments로 나뉘게 된다.

![Untitled](Network%20Layer%20-%20Fragmentation,%20IP,%20Subnet%209b748ebe6cd5469286a8469291c29568/Untitled%205.png)

호스트나 라우터에는 네트워크 카드(하드웨어)가 들어가며, 이를 통해 유무선 네트워크에 연결되어 인터페이스(ip 주소 등)를 얻습니다. 라우터는 여러 인터페이스를 가지고 있고, 호스트는 보통 2개(이더넷, 와이파이)의 인터페이스를 가지고 있습니다.

호스트(PC)와 라우터는 링크로 연결되어 있습니다. 링크 레이어를 통해 단순히 데이터를 전송합니다. 라우팅은 링크 레이어가 아닌, 라우터에서 이루어집니다.

![Untitled](Network%20Layer%20-%20Fragmentation,%20IP,%20Subnet%209b748ebe6cd5469286a8469291c29568/Untitled%206.png)

인터페이스 간 연결은 실제로는 Switch를 이용하여 연결되어 있습니다. 하늘색으로 묶인 부분이 같은 네트워크 ID(아래 참고)를 구성하고 있는 군집입니다. 라우터는 일반적으로 여러 인터페이스를 가지고 있는데, 라우터 주변에 있는 숫자를 보면, 223.1.X.X 와 같이 X로 된 부분이 변하는 것을 볼 수 있습니다. 이를 주목해 봅시다.

![Untitled](Network%20Layer%20-%20Fragmentation,%20IP,%20Subnet%209b748ebe6cd5469286a8469291c29568/Untitled%207.png)

IP 주소의 경우 네트워크 식별자와 호스트 식별자 부분으로 나누고, 이를 클래스로 나누게 됩니다. 처음에 군용으로 인터넷을 도입했기 때문에 용도에 따라 클래스를 나누어 사용했었습니다. 하지만 오늘날에는 민간 영역에도 적용하고 있는데, 이처럼 나누게 되면 너무 클래스 간 다룰 수 있는 범위의 차이가 크므로 각 구분 영역이 비효율적이었기에 오늘날에는 잘 사용하지 않습니다. 따라서 서브넷이라는 개념이 등장하게 됩니다.

## Subnet

---

![Untitled](Network%20Layer%20-%20Fragmentation,%20IP,%20Subnet%209b748ebe6cd5469286a8469291c29568/Untitled%208.png)

![Untitled](Network%20Layer%20-%20Fragmentation,%20IP,%20Subnet%209b748ebe6cd5469286a8469291c29568/Untitled%209.png)

클래스만을 이용하여 네트워크 ID만 구분하기엔 비효율적이었기에 서브넷이 등장하게 되었습니다. 즉, 오늘날에는 호스트 ID를 구분하기 전에 네트워크 ID와 서브넷 ID를 구분하게 되는 겁니다. 서브넷은 예를 들어 학교의 IP주소를 구성할 때, 소프트웨어학과, 전자과 등의 주소 군집을 형성할 수 있습니다. (클래스로만 구분할 때 보다, 서브넷을 이용함으로써 네트워크 관리에 소요되는 오버헤드를 줄일 수 있습니다.)

엄격하게 구분하면 위처럼 되지만, 일반적으로는 네트워크 ID를 172.217.24 까지로 보고, 196을 호스트ID로 인식하게 됩니다. 이렇게 본다면, 네트워크 ID가 같다면 같은 서브넷 안에 있으므로 라우터를 거치지 않고 링크로 연결되어있는 군집 내에 있다고 말할 수 있는 겁니다.

그리고 서브넷 마스크는 서브넷의 사이즈를 나타냅니다. 여기서의 크기란 몇 개의 호스트를 수용할 수 있는가의 의미이며,  `54:14`

![Untitled](Network%20Layer%20-%20Fragmentation,%20IP,%20Subnet%209b748ebe6cd5469286a8469291c29568/Untitled%2010.png)

라우터를 거치지 않는 영역까지를 서브넷이라고 합니다. 서브넷 내부의 호스트는 라우터로 연결되어 있지 않습니다. 같은 서브넷 안에서는 라우터를 거치지 않고 링크로만 연결(물리적으로 연결)되어있고, 스위치로만 묶여있는 영역인 겁니다. 즉, 위 그림에서는 서브넷이 3개 존재하게 되는 겁니다.

![Untitled](Network%20Layer%20-%20Fragmentation,%20IP,%20Subnet%209b748ebe6cd5469286a8469291c29568/Untitled%2011.png)

싸이더(CIDR)는 클래스를 사용하지 않는 ip addr 분할 방식입니다. 여기서는 ip addr을 class a, b, c 등으로 나누지 않고 비트로 나누게 됩니다.

즉, `0.0.0.0/비트수` 로 표현하여 네트워크ID부분(서브넷 부분)을 몇 비트로 표현하는지를 나타냅니다. 위의 예시를 해석해보면 `200.23.16.0/23` 이므로 총 32비트 중 23비트를 네트워크ID 표현에 사용하므로, 호스트 ip addr는 32-23 = 9 이므로, 총 2**9 개 == 512개 만큼 표현할 수 있다는 의미입니다.

클래스 A,B,C를 CIDR로 표현해보면 A → /8 이므로 2**24개 == 약 16백만개 , B → /16 이므로 2**16개 == 약 64,000개, C → /24이므로 2**8 == 256개 입니다. 각각 32와의 차를 이용하여 2의 n승을 해보면 수용할 수 있는 호스트의 개수를 알 수 있습니다.

![Untitled](Network%20Layer%20-%20Fragmentation,%20IP,%20Subnet%209b748ebe6cd5469286a8469291c29568/Untitled%2012.png)

위 예시를 해석하면 다음과 같습니다.

1. MCI라는 회사가 우선 208.128.0.0/11의 IP 주소를 할당 받았습니다. 따라서 MCI는 약 4백만 개의 주소를 사용할 수 있습니다.
2. MCI가 소유한 영역 중에서 208.130.28.0/22영역에 ARS를 할당한 겁니다. 
3. ARS는 그 중에서 2개의 비트를 할당하여 4개의 서버를 이용하고, 그 중에서 public servers를 위한 네트워크 ID를 208.130.29.0/24만큼 할당하게 됩니다. 즉, 이 서버 아래의 호스트는 256개를 가질 수 있는 거죠. 
4. 그 중에서 하나가 바로 208.130.29.33/32 로 전체 ip addr를 호스트 주소로 갖는 프리소프트 기관의 ip 주소가 된 겁니다.

위와 같은 방법이 등장한 배경도, 클래스로만 구분할 때에 IP 주소 고갈 문제가 발생할 수 있었기 때문입니다. 하지만 CIDR를 이용하더라도 IP 주소의 고갈을 막을 수 없었고, 결국 이 고갈을 해결하기 위한 해결책으로 제시된 것이 DHCP, NAT, IPv6가 있습니다.